\documentclass[a4paper,11pt,draft]{article}
\author{Jarrah Gosbell}
\title{CYSEC Training Program}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{%
	        \markright{\thesection\ #1}}
\fancyhf{}  % delete current header and footer
\fancyhead[L,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{2pt} % space for the rule
\fancypagestyle{plain}{%
	   \fancyhead{} % get rid of headers on plain pages
	      \renewcommand{\headrulewidth}{0pt} % and the line
	  }
\usepackage[pdftex]{hyperref}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Computer Operations}
	A computer can be thought of in terms of the systems which make it up, and the layers of those systems.
	At the base level, a computer is a structure of silicon, etched into the shape of a CPU die, then added into a bus with memory and IO.
	At the next level, the binary signals which are processed are taken into account, allowing the computer to act in a programmed way. 
	Finally, a computer is programmed in a language such as C or Python. This gives us the interfaces and systems which we interact with daily. 
	\subsection{Hardware}
		\subsubsection{CPU} 
			The CPU is the microprocessor which forms the heart of the modern computer. 
			While not the only microproccessor in a modern computer, they are the most major and the one which is commonly programmed for. 
			This lesson will discuss the current design and implementation of CPUs, and the impact of this on the way that a computer works. 
			This will be broken down into the fetch, decode, execute cycle, the physical units which make up the CPU and the connection which allows it to commuticate with the rest of the computer. 
			\paragraph{Fetch, Decode, Execute Cycle}
				The operation of a computer occurs through the repeated execution of a sequence of instructions.
				This cycle allows the computer to access the instructions stored in cache or RAM and determine how they should be enacted. This lesson will discuss the approach used on a classic RISC CPU similar to that of most modern phones. 
				Due to this, it will discount cache and threading. 
				\subparagraph{Fetch}
					This step requires the CPU to request the next instruction from it's source. 
					This is possible as the CPU retains the address of the next instruction to complete in it's program counter. 
					After each fetch, the CPU will increment the address in its program counter. 
					However, this address may change due to the requirements of the instruction which was just fetched. 
					If the instruction has to be fetched from RAM rather than cache, the CPU may stall while waiting.
					This will freeze execution until the fetch cycle has been completed. 
				\subparagraph{Decode}
					This step is performed on the Instruction Decoder, where the instruction which was fetched in the last step is converted into the signals which control other parts of the CPU to enact the instruction. 
					This decoding will occur based on the instruction set of the processor, which can be thought of as a look-up-table for valid instructions. 
					This will intrepret the first section of the instrcution, known as the opcode, and determine which signals must be sent to have the CPU execute the instruction. 
					The later fields are then sent as arguements to supplement the instruction. 
					This process may take place on a hardwired circuit, or through the use of a microprogram which, In either case the system output will be the same. 
					However, in the latter case, the microprogram will be rewritable, allowing for decoding to be altered after production. 
				\subparagraph{Execute}
					This step causes the CPU to enact the requirements of the instruction, causing output to be written to a given register or memory location. 
					This may occur over multiple clock pulses, with each designating a new section of the instruction. 
					This can be seen through the action of the Arithmetic Logic Unit, which will perform its calculation to ensure that its output is stored in the register by the next clock pulse. 
			\paragraph{CPU Structure}
				The CPU is made up of multiple parts which allow it to conduct its role within the computer. 
				Each of these parts perform only one task within the CPU, allowing others to process or store their output. 
				The most important of these components will be explained here. 
				\subparagraph{The Control Unit}
					Contains the circuitry which intreprets instructions and creates electrical signals which direct other parts of the CPU to carry out the instructions. 
					The control unit is also the communicator between the ALU and the Memory.
				\subparagraph{The Arethmetic Logic Unit}
					(ALU) is the processor for both integer and bitwise logic. 
					The inputs for this circuit are the decoded signals from the Control Unit, as well as the Operands (arguements) which were passed with the instruction. 
					Once the calculation has taken place, the ALU will output to either the register or memory location designated by the instruction. 
				\subparagraph{The Floating Point Unit}
					(FPU) is the logic circuit used to calculate floating point (real) numbers. 
					While these numbers can be computed using only the ALU, it is not optimized to calculate them.
					Thus to expediate the process an FPU was created. 
					These units will calculate mathematics on real numbers to a given precision (specified by the IEEE). % Reference this
					When a given precision is not supported, the ALU must run the calculation at a far slower pace. 
				\subparagraph{The registers}
					The CPU also contains its own extremely fast memory, known as regsters. 
					These blocks of memory are capable of being used as operands for instructions, and are commonly both the output and the input of a CPU instruction.\\ 
					There are specific uses for registers in the x86 CPU: \footnote{http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html}
					\begin{itemize}
						\item General Registers: 
							\subitem RAX is the Accumulator register for IO, arithmetic, interrupt calls, etc. 
							\subitem RBX is the Base Register used as a base pointer for memory access. 
							\subitem RCX is the Counter register, used for loop counters. 
							\subitem RDX is the Data Register used for IO, arithmetic and interrupt calls. 
						\item Segment Registers: 
							\subitem CS holds the current code segment. 
							\subitem DS holds the data segment of the current program. 
							\subitem ES, FS, GS are extra segment registers for far pointer addressing such as video memory. 
							\subitem SS Holds the Stack segment of the current program. 
						\item Index and Pointer Registers: 
							\subitem RSI Source index register for string and memory array copying
							\subitem RDI Destination index register used for string and memory array copying
							\subitem RBP holds the stack base pointer. 
							\subitem RIP is the index pointer. Holds the offset of the next instruction. 
							\subitem RSP is the stack pointer. Holds the current head of the stack. 
						\item CFLAGS holds the current state of the processor and the output or error of some instructions after execution. The use for each CFLAGS bit can be found in table \ref{tab:CFLAGSBits} 
							\begin{table}[htb]
								\centering
								\begin{tabular}{| l | l | l |}
									\hline
									\textbf{Bit} &  \textbf{Label} &   \textbf{Desciption} \\\hline 
									0   &   CF &     Carry flag \\ \hline
									2   &   PF   &   Parity flag \\ \hline
									4   &   AF   &   Auxiliary carry flag \\ \hline
									6   &   ZF   &   Zero flag \\ \hline
									7   &   SF   &   Sign flag \\ \hline
									8   &   TF   &   Trap flag \\ \hline
									9   &   IF   &   Interrupt enable flag \\ \hline
									10  &   DF   &   Direction flag \\ \hline
									11  &   OF   &   Overflow flag \\ \hline
									12-13 & IOPL &   I/O Priviledge level \\ \hline
									14  &   NT   &   Nested task flag \\ \hline
									16  &   RF   &   Resume flag \\ \hline
									17  &   VM   &   Virtual 8086 mode flag \\ \hline
									18  &   AC   &   Alignment check flag (486+) \\ \hline
									19  &   VIF  &   Virutal interrupt flag \\ \hline
									20  &   VIP  &   Virtual interrupt pending flag \\ \hline
									21  &   ID   &   ID flag \\ \hline
							\end{tabular}
							\caption{CFLAGS bit uses}
							\label{tab:CFLAGSBits}
						\end{table}
				\end{itemize}
			\subparagraph{Protected Mode} 
				is the mode of operation for the modern CPU. 
				This stemed from security and multiprogramming issues found to occur in real mode. 
				In real mode, the current program can access all of the memory of the system, allowing it to overwrite that of other programs. 
				In protected mode, the segments used by each program are tracked by the processor to ensure that a program cannot write outside of it's own segment. 
				This is why we cannot run a buffer overflow into another program, the processor would pick it up and the program would segmentation fault. 
				\subsubsection{RAM}
					%TODO: Add in section on segments of memory and protected mode. 
					The main memory of a computer, known as Random Access Memory (RAM) is the first storage device of the computer outside that of the processor. 
					RAM is used because it is fast, however, this comes at the loss of price and volatility. 
					When no electrical current is passing through RAM modules, the data held within will deteriorate. 
					The speed at which this occurs forms the basis for cold boot attacks. %TODO: Ref this to forensics. 
					For our purposes, memory should be thought of in terms of the segments and data structures which make it up. 
					\paragraph{The .BSS section}
						is the section of memory used for static and global variables. 
						Generally the variables outlined in this section are not initialised until the program is running. 
						A .BSS variable may be a memory location that you wish to store a string in later in the program. 
					\paragraph{The .data section}
						is the section for global variables which are to be initialised before the program starts. 
						This is where you would put the data which is to be accessed by the program, rather than through inputs or environmental variables. 
					\paragraph{The .code section}
						is the section which contains the code for the program. 
						It cannot create new variables, but it can access those created in the .BSS and .data sections. 
						This section is usually broken through the use of labels and navigated by jump statements. 
						One should be careful to ensure that these statements do not become hard to follow. 
					\paragraph{The Heap}
						is the structure used to store larger memory items in a high level programming language. 
						In an object oriented language, items stored on the heap are usually created through the use of the ``new'' command. 
						In procedural languages, commands such as ``malloc'' are used to allocate memory to the heap. 
						In both of these instances, the command will allocate the necessary memory and return a pointer to that address. 
						Items stored on the heap start at lower memory locations and move to higher as more items are placed on the heap. 
						This will become important as we move to binary exploitation. 
					\paragraph{The Stack}
						is the more widely used memory structure. 
						Variables in any language as soon as they are named are stored on the stack frame of the current scope. 
						Even items stored on the heap have a pointer on the stack. 
						The program will create a new stack frame---a collection of instance variables---for each scope which it comes across. 
						This is best seen in functions, where the frame for main() will sit on the stack, followed by the frame of the first function called, followed by the next. 
						Each of these functions would have their own instance variables, all of which are stored within their frame. 
						When the function returns, its frame is popped from the stack and the stack pointer is raised to the last frame. 
						Unlike the heap, the stack starts at high memory locations and grows down towards the heap. 
						This can be used for overflows into heap variables. 

	\subsection{Assembly And Binary}
		While we may find it easier to interact with computers using high level programming languages or even pre-written programs and graphics, an understanding of how a computer works at the low level is required to properly exploit its process. 
		The first computer programs were written algorithmically, before being translated manually into binary or octal (base 8). 
		The program had to be inputted manually, one instruction at a time. 
		However, due to modern compilers, this has become unnecessary, since 1949 we have been able to automatically assemble programs into machine code. 
		This meant that assembly languages became the norm, allowing people to write programs at a far greater speed.
		These assembly programs, while directly mapped to the opcodes of binary computers were written in a form close to English and far more understandable than binary. 
		We have now left this time behind through the use of compiled languages. 
		However, an understanding of assembly is still necessary due to the difficulty of returning from binary to source code. 
		\paragraph{Binary}
			on a computer is everything. Every file, every program, every instruction is binary. 
			However, this is meaningless without some means of translating the numbers into their useful form. 
			This has led to instruction sets, file types, encodings and data types, each with their own means of translating the numbers found in binary into some meaningful representation. 
			For example, the source of this document is written in UTF-8, a superset of the ASCII format which translates binary numbers into characters. 
			Generally, this binary will be viewed either in the decoded form through a program such as a text editor (for UTF-8 or ASCII). 
			However, in cases where the format is not obvious, a hex editor would be employed. 
			These editors allow one to see the binary code in base 16 rather than base 2, reducing its length by a factor of 8. 
			Furthermore, these editors will display a ASCII representation of any text found, allowing one to read strings out of the file. 
			Another program, known as strings will automate the process of finding ASCII strings in binary. 
			Though it is exceptionally widespread, one need not understand binary in order to utilise these tools. 
		\paragraph{Assembly}
			
\section{Network Operations}
	\subsection{OSI Model}
	\subsection{Network Architecture}
	\subsection{Connecting To Networked Software}
\section{Scoping and Mindset}
	\subsection{Lock Picking}
	\subsection{Research}
\section{Web Penetration}
	\subsection{XSS}
	\subsection{SQL Inejection}
	\subsection{File Uploads}
\section{Network Penetration}
	\subsection{nmap}
	\subsection{Nessus}
	\subsection{Metasploit}
	\subsection{Pivoting}
	\subsection{Maintaining a presence}
\section{Forensics}
	\subsection{File Carving}
	\subsection{Steganography}
	\subsection{Wireshark}
	\subsection{Netflow}
\section{Reverse Engineering}
	\subsection{x86 Assembly}
	\subsection{Radare2}
	\subsection{Pwn Adventure}
\section{Programming}
	\subsection{Introduction to Python}
	\subsection{Compilation}
	\subsection{Introduction to C}
	\subsection{Introduction to Scripting}
	\subsection{Programming Challenges}
\section{Cryptography}
	\subsection{Introduction to Cryptography}
	\subsection{Utilizing Cryptography in Python}
	\subsection{Poor Cryptography Implementations}
\section{System Hardening}
	\subsection{Linux Hardening}
	\subsection{Windows Hardening}
	\subsection{Browser Hardening}
		Hardening a web browser is a long process. However it is easier than hardening an OS, and it's cross platform. 
		The first step, as with all things is to ensure that you trust the browser you are using and have it updated. 
		When deciding trust, ensure that the browser is coming form a source you trust, and preferably open source and well known. 
		Once this is complete, we begin looking into plugins and 
\section{Reporting}
	\subsection{Report Writing}
	\subsection{STIX Model}
\section{Binary Exploitation}
	\subsection{Overflows}
	\subsection{String Format Errors}
	\subsection{IDS, IPS and AV}
\section{History}
	\subsection{MIT Tech Model Railroad Club}
	\subsection{Early Computing Equipment}
\section{Wireless Attacks}
	\subsection{Aircrack-ng}
	\subsection{Bluetooth}
	\subsection{Near Field Communications}
	\subsection{Challenges}
\newpage
\listoftables
\end{document}
