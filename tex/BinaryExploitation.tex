\chapter{Binary Exploitation}
	\label{ch:BinaryExploitation}
		The execution of a program usually follows a specific set of instructions to the letter. 
		However, mistakes in programming can allow these instructions to be altered or fail. 
		When this occurs, usually the program will crash by some means, stopping execution completely. 
		This is the desired outcome because it ends any vulnerability that the program might have. 
		However, when the environment is carefully controlled, one can use these mistakes to take control of the program, 
		allowing them to execute arbitrary code through the program.\cite{HackingAOE} 
		This is the goal of this section, to craft the environment in such a way that the program can be used to do our bidding. 
	\section{Shellcode}
		Shellcode\index{Shellcode} is the payload that is executed within an exploited program to cause it to act in the way we want.\cite{HackingAOE} 
		This code is often written in Assembly and is written directly into memory to be run by an altered return pointer or some other means of altering execution flow. 
		There are many examples of shellcode available online. 
		These will do most of what you will need, however, knowing how to read and write shellcode will allow you to check that the code you are running will do what you require. 
		Furthermore, if you want to run an exploit which will do a specific task (such as add an admin user), you will likely not find the shellcode you require. 
		Once you understand the creation of shellcode, your exploits are limited only by your destructive insights. 

		Shellcode is written for a specific computer architecture, mainly due to the fact that it is written in assembly.
		A strong grasp of the assembly language syntax for your target computer as well as its configuration will help you to create a working shellcode. 
		Thus, it is recommended that in the scoping and framing section of your attack, you find out as much about the system as you con. 
		Furthermore, a strong grasp of the filesystem and configuration quirks of the target system will allow you to alter the configuration to meet your needs. 
		For the programming concepts that you will need to understand before writing shellcode, read through the assembly section in chapter \ref{ch:ComputerOperations}
		Note that much of the assembly that you will see in this section is not well written for efficiency but rather is written to assemble into the smallest shellcode possible. 
		When writing assembly for other purposes, you should not use actions such as pushing something to the shell and popping it into a register without good reason. 
		\subsection{Data in Shellcode}
			Shellcode can be thought of as a virus, with the program that it is stealing execution from being the biological body. 
			Due to this, shellcode is not a fully fledged program in itself. 
			This means that the shellcode will have to be self contained within its instructions, attempts to use variables in other parts of memory will fail. 
			This is known as position-independent code. 
			Due to this, when one is writing shellcode, they must store any data within the instructions of the program. 
			This, however, raises issues with establishing a pointer to the data, which must be calculated from the instruction pointer. 
		
			To solve this problem, we place the string data directly after a call instruction, causing it to push a pointer to the data onto the stack as the return address. 
			Then, we can jump past the data by using a pop instruction to move its address into a register of our choosing. 
			The following code snippet shows this process:
			\begin{code}
				\lstinputlisting[language={[x86masm]Assembler}]{./ShellcodeData.asm}
				\caption{Getting a Data Pointer in Shellcode}
				\label{code:ShellcodeData}
			\end{code}

			As an exercise, alter this code to print the data is pointed to by RCX. 
			This will be used in the following section for showing a working buffer overflow. 

		\subsection{Writing Shellcode into a Program}
			Often shellcode will be written into a program through means such as environmental variables. 
			However, doing this usually involves C functions such as strcpy, which terminates at the first null byte encountered. 
			The shellcode shown in \ref{code:ShellcodeData} when assembled contains multiple null bytes, such as the string of them after the call instruction.
			These must be removed before the shellcode can be inserted within another program. 
			This call function contains null bytes due to the fact that it is only moving the instruction pointer a small distance. 
			This means that the small number that is placed into the call instructions operands is padded by null bytes. 
			To solve this, we can put the label (``get\_ptr'') above the call command. 
			This will place the twos complement negative number for the jump after the call instruction, removing the null bytes. 
			Further, to get this to work the command ``jmp short one'' must be added to the top and the label ``one'' must be added above ``call get\_ptr''.

			Similarly, null bytes are often found in the operands of other instructions. 
			These can be resolved by only using the needed segments of registers and nulling them out manually by xoring them from themselves. 
			Registers such as RAX are 64 bits long, however, they are made up of EAX (the first 32 bits), AL and AH (The first and last 16 bits of EAX respectively).
			By using these registers, the assembler can condense the code rather than padding it with null bytes. 

			After this, the shellcode should be ready to use. 
			Write it to an environmental variable using the command ``export SHC=\$(cat <assembled shellcode>)''
			%TODO: This is not finished
		\subsection{Popping a Shell}
			Now that most of the difficult concepts have been covered, we will spawn a useable shell using the program we have exploited. 
			This is done through system call 11, ``execve()'' which when given the argument ``/bin/sh'' will pop a shell for you. 
			See man 2 execve for further information on this command. 
			Code example \ref{code:ShellcodePop} is an example of shellcode which uses this method to pop a shell. 
			\begin{code}
				\lstinputlisting[language={[x86masm]Assembler}]{./ShellcodePop.asm}
				\caption{Shellcode to Pop a Shell}
				\label{code:ShellcodePop}
			\end{code}
			The instructions used for formatting the addresses such that they can be used may be confusing at first. 
			See figure \ref{fg:ShellPopMemory}. 
			for a depiction of memory at this time. 
			\begin{figure}[htb]
				\centering
				\begin{tabular}{| l | c | c | c | c | c | c | c | c |}
					\hline
					RAX	& 0x00 	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00 \\ \hline
						& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00 \\
					\hline
					\hline
					[RBX] 	& 0x2F & 0x62 & 0x69 & 0x6E & 0x2F & 0x73 & 0x68 & 0x00 \\ \hline
						  & addr & addr & addr & addr & addr & addr & addr & addr \\ \hline
						  & 0x00 & 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00	& 0x00 \\
					\hline
				\end{tabular}
				\begin{tabular}{| l @{ -> } l |}
					\hline
					RCX & argv string array. [RBX+8] \\ \hline
					RDX & envp pointer array. Null. [RBX + 16] \\
					\hline
				\end{tabular}
				\caption[Depiction of memory after shellcode]{Depiction of Memory After Code Example shellcode pop} %TODO: fix reference
				\label{fg:ShellPopMemory}
			\end{figure}

			Try writing your own version of the shellcode in code example \ref{code:ShellcodePop} and running it against the code in \ref{code:OverflowChallenge}. You should be able to get a shell. 

			\subsection{Attacking Remote Targets}
				The shellcode so far has been useful for attacking a local system only. It cannot communicate with an external computer in order to give that computer access. 
				To have a shell that we can use remotely at the end of the attack, we need to have the shellcode bind a port and listen for our communication over that port. 
				Thus, we will be using the system calls ``socket''\footnote{\url{http://linux.die.net/man/2/socket}}, 
				``bind''\footnote{\url{http://linux.die.net/man/2/bind}}, 
				``listen''\footnote{\url{http://linux.die.net/man/2/listen}} and 
				``accept''\footnote{\url{http://linux.die.net/man/2/accept}} to have the operating system do this for us. 
				However, the use of these system calls requires the creation of a C struct within the shellcode that we write. 
				The shellcode example \ref{code:ShellcodePort}\footnote{\url{https://www.exploit-db.com/exploits/39151/}} shows the creation of a socket connection to another computer. 
				This can then be extended to allow communication through these sockets to a shell spawned by the shellcode in %TODO: ref next code. 
				\begin{code}
					\lstinputlisting[language={[x86masm]Assembler}]{./ShellcodePort.asm}
					\caption{Shellcode to bind a shell to a port}
					\label{code:ShellcodePort}
				\end{code}
				This shellcode on its own will allow you to check that connection can be established, but will not allow any access to the remote computer. 
				However, this functionality can be added by creating a number of file descriptors for the socket and binding them to the standard input, output and error of the shell. 
				The shellcode in shellcode example \ref{code:ShellcodeSHPort}, when executed after \ref{code:ShellcodePort} will bind a shell to the socket described by the register ``r9''. 
				\begin{code}
					\lstinputlisting[language={[x86masm]Assembler}]{./ShellcodeSHPort.asm}
					\caption{Shellcode to bind a shell to a socket}
					\label{code:ShellcodeSHPort}
				\end{code}
				When these two examples of shellcode are combined and executed, they will create a socket on port 4444 and bind it with the IO of a shell. 
				This will then be accessible to anyone connected to the socket created. 
				When working with remote programs, this is the minimum shellcode required in order to be able to interact with the shell which is spawned. 
				Without this, the program would drop a shell on the system but not be accessible to you. 
				
				The above shellcode, while useful for training, will not work in most situations where a firewall is used. 
				This is due to the fact that most firewalls block incoming connections which were not proceeded by an outgoing connection to the same address. 
				Thus, a better shellcode would attempt itself to connect to the attacker, rather than passively waiting. 
				This will bypass most simple firewall protections. 
				As a challenge, alter the shellcode in example \ref{code:ShellcodePort} to have it conduct a reverse connection. 
				A solution to this can be found in shellcode example \ref{code:ShellcodeReversePort} in the challenges section below. 

	\section{Overflows}
	\index{Buffer Overflows}
		While newer languages run their own data integrity checks, many program are written in older or faster languages which do not. 
		C and many of its derivatives do not run these checks, allowing a programmer to make mistakes in memory allocation and buffer writing. 
		While this increases the control given to the programmer and makes for far simpler compilers, it also means that a careless programmer may create vulnerable code. 
		For example, in C, if a program has been told to put 10 bytes into a 2 byte buffer, it will, while in languages such as Java, this will result in an exception. 
		It is this error in memory allocation which is known as the buffer overflow, and which this section will focus on. 

		Programmatically, the most common buffer overflow is when a string or input is copied to another location. This can be seen in %TODO:Ref below table. 
		\begin{code}
			\lstinputlisting[language={[ANSI]C}]{./OverflowSimple.c}
			\caption{Simple Buffer Overflow Example}
			\label{code:OverflowSimple}
		\end{code}
			On reading the above code in \ref{code:OverflowSimple} you should notice the unbounded copy of anything given as the first argument into the second buffer. 
			This means that if you pass more than 8 bytes to the program, it will copy them into second\footnote{This will not work on OS X or a well secured Linux system due to buffer bounds checking}, overwriting anything beyond its allocated memory. 
			For example:
			\lstinputlisting[numbers=none,firstline=1,lastline=9]{./shellOut/bufOver.out}
			Note that here we altered the content of first by writing to second. 
			This is because each item on the stack is placed at a lower memory location than the item before it. 
			Writing beyond an items bounds will overwrite variables stored in higher memory locations. 
			This can further be seen through the variable changes' hex output, which contains repeated 0x61, the hex value for a. 
			The size and content of the argument will allow you to alter the variables first and change to any arbitrary value.
			However, a longer overflow string may cause the program to crash. 
			See code example \ref{code:OverflowChallenge} in the challenges section of this chapter for another vulnerable code example. 

			Rather than just targeting the variables written into the code, we can also target normal program functions,
			such as the return address of the current stack frame. 
			As discussed in chapter \ref{ch:ComputerOperations}, 
			each function call within a program adds a frame to the stack and each return call follows a pointer back to the memory location of the instructions that the call was initially made. 
			As this pointer lies at the highest memory location in the current stack frame, it is vulnerable to be overwritten through the overflow exploit discussed above. 
			To determine its location, open GDB on code example \ref{code:OverflowChallenge} and run the command ``dissass main'', which will show you the assembly code of main. 
			\lstinputlisting[numbers=none,firstline=11,lastline=27]{./shellOut/bufOver.out}
		The two bold lines show the return address being calculated and the call to the checkAuth function. %TODO: Add a test to use ShellcodeData.asm 

	\section{String Format Errors}
	\index{String Format Vulnerability}
		Much like buffer overflows, string format errors can be used to write to memory and eventually redirect the control flow of the program. 
		This vulnerability uses the standard string format codes, seen in table \ref{tab:StringFormatCodes}, which can be inserted into vulnerable inputs. 
		While these formats are useful in programming and not naturally malicious, many, such as the \verb+%n+ and \verb+%x+ codes are exceptionally useful in writing to and mapping memory respectively. 
		Using these, we can write any arbitrary value or memory location into most parts of the stack.
		
		We can achieve this due to the fact that a proper call to printf (or any other function) pushes each of the arguments for the call to the stack in reverse order. 
		The format function will then iterate through these arguments, but rather than counting the number that came in, it will simply count the number of format codes it finds. 
		This means that the function will continue to read from memory, even when no arguments were pushed for it. 
		\subsection{The Vulnerability}
			The string format vulnerability occurs when the printf function is misused with user input strings. 
			Printf should be called using the syntax ``printf("\verb+%s+", string)'', which will not parse the variable ``string'' for format codes. 
			However, occasionally a programmer will call it as ``printf(string)'', at which point printf will parse for and execute all string format codes found within the variable ``string''. 
			When these are picked up, the printf function will look to the next item down the stack, inserting that as its format parameter. 
			An example of this vulnerability can be seen in code example \ref{code:StringFormatVuln}.
			\begin{code}
				\lstinputlisting[language={[ANSI]C}]{./StringFormatVuln.c}
				\caption{Example of the String Format Vulnerability in Code}
				\label{code:StringFormatVuln}
			\end{code}
			Using this example, attempt to have it write parts of the stack. 
			Try to find items such as return locations and environmental variables. 
			They will be useful later on. 

		\subsection{Writing to Memory Addresses}
			We have been able to read to memory addresses lower on the stack than our print call quite easily. 
			The only thing necessary for this was using \%x statements. 
			However, writing to an arbitrary memory address is more difficult. 

			Printf conveniently provides a method of direct parameter access that can be used to write to a specific location. 
			This is done by specifying ``\%y\$n'' where y is an integer used to specify the number of steps to go down the stack before writing. 
			This will still write the number of bytes which have been printed, giving you an easy way to write arbitrary values to parts of the stack. 
			
			When attempting to write memory addresses into variables or the return pointer on the stack frame, it is best to use two short writes. 
			This can be done using the ``h'' modifier within the ``\%n'' parameter, which will tell it to write only a short (16 bit) value. 
			This means that full 32 bit and 64 bit memory addresses can be written to arbitrary locations within the applications memory, allowing you to control the flow of the program. 

			Using this vulnerability, one can overwrite any memory location within the program. 
			Using thin knowledge, find other memory locations which may be worth overwriting. 
			They can lead to some interesting consequences. 
	\section{libc Attacks}
	\section{IDS, IPS and AV}
	\index{Intrusion Detection System} \index{Intrusion Prevention System} \index{Antivirus}
		These are systems designed to stop you getting into a system or to alert the user and enact a script when an intrusion is detected. 
		While they do make attacks more difficult, none has yet been designed that is perfect. 
		There are a number of methods for avoiding these systems, some of which will be explained here. 

		\subsection{Invisibility}
			When you are attacking a target, you will often be unexpected. 
			This means that you may be able to get into the system without being noticed. 
			Rather than opening with the loudest scan and most powerful attack even though you don't know whether it will get you into the system,
			simply take the time required to run another scan and do a little more research. 
			The extra time will give you the opportunity to enter the system undetected. 
			When you have root access to a system and haven't been detected entering, you are the most powerful and dangerous user of the system. 

		\subsection{Exploiting Without Breaking}
			Another means of becoming invisible is to ensure that the program that you use to exploit does not break immediately when you exploit it. 
			Ensuring that the program doesn't stop will make your attack far less obvious, but is far harder than just running an exploit. 
			This can be done initially by setting up a return address within the shellcode to return execution to the main program. 
			However, while this may work, it will also likely cause the program to crash due to the damage that was done in writing and executing the shellcode in the first place. 
			
			Thus, if you can get a local copy of the program running to test it on, you should run the program through a debugger, checking for the memory that you have likely overwritten and repairing it. 
			This is usually done by adding a breakpoint instruction within your Shellcode (such as the ``int3'' instruction) and then running it on the target program within GDB. 
			When viewing this, the damage that you have done should be obvious, and thus can be repaired within your shellcode. 

			Further to this, you will also have to ensure that the process that you are targeting doesn't have a distinct pause while your shellcode is running. 
			This means that your shellcode should fork into another thread or process as soon as possible. 
			This can be done using the fork system call then having the parent clean up and return to the main process. 
			In order to do this, one must remember that the fork system call will return 0 in the child process, but the new PID in the parent. 
			This can be used to make the parent (non-zero return) conduct the clean up while the child continues to process your shellcode goals. 
			\begin{code}
				\lstinputlisting[language={[x86masm]Assembler}]{./forkShellcode.asm}
				\caption{Shellcode that forks such that the original thread can continue. }
				\label{code:ForkShellCode}
			\end{code}

		\subsection{Firewalls}
		\index{Firewalls}
			This is another aspect that must be thought about. 
			Even a simple firewall will often block a number of suspicious ports, such as 31337 which has historically been used for malicious purposes. 
			However, a more complex firewall will have rules stating that a normally inbound serving service such as a webserver should not be able to create an outgoing connection. 
			Thus, you will have to determine what is going on with the firewall on the system you are targeting and work around its rules. 

			One way to do this is to reuse sockets within the program. 
			This has the added bonus of not logging anything extra as no new socket is created. 
			However, it also means that the firewall has already allowed the connection to be created, meaning that the shell will not be caught within its rules. 
			Remembering that when we exploit a program, out exploited version will still have total access to the memory of the original, even if we have forked it to create a new process. 
			Thus, we can take the file descriptor which was used to communicate and bind it to our shell. 
			This is done by debugging the target program and finding the address of the socket that we would like to use, then loading that address and using it in our bind calls. 

		\subsection{Payload Smuggling}
			Many IDS or IPS systems will scan the contents of the packets that are being sent over the network. 
			This will stop most of the shellcode that we have been creating in this chapter, as the goal of the code is quite obvious. 
			However, this can be stopped using a method known as payload smuggling, which will obfuscate the payload to the point that the casual reader or fast acting IDS would not notice it. 

			The easiest way to do this is to encode parts of the shellcode. 
			The most obvious of these is strings such as ``/bin/bash'', which will be picked up by even the most basic IDS. 
			However, after running these through a XOR function, we have simple binary data which will not be picked up by the IDS. 
			So long as we retain the key this data can be returned to its original form and used within the program. 

			A further attempt at this within a highly secure environment is to use this XOR function on the whole shellcode, leaving only a decoder and loader in memory. 
			While this is far more complex, it means that no statically scanning IDS will be able to detect your shellcode unless you are using a known key. 

			Further to this, the NOP sleds that are commonly used within shellcode are quite obvious to an IDS as they are rarely if ever used in the normal world. 
			However, table \ref{tab:NOPAlternatives} shows a list of instructions, their hex values and their ASCII interpretations that can be used instead. 
			\begin{table}[htb]
				\centering
				\begin{adjustbox}{max width=1\textwidth}
				\begin{tabular}{| l | c | l |}
					\hline
					\textbf{Instruction} & \textbf{Hex} & \textbf{ASCII} \\ \hline
					inc eax	& 0x40 & @ \\ \hline
					inc ebx & 0x43 & C \\ \hline
					inc ecx & 0x41 & A \\ \hline
					inc edx & 0x42 & B \\ \hline
					dec eax & 0x48 & H \\ \hline
					dec ebx & 0x4B & K \\ \hline
					dec ecx & 0x49 & I \\ \hline
					dec edx & 0x4A & J \\ \hline
				\end{tabular}
			\end{adjustbox}
				\caption{NOP Sled alternatives}
				\label{tab:NOPAlternatives}
			\end{table}
			As the registers need to be zeroed out before use anyway, it is fine to use these instructions rather than creating a NOP sled as they will be executed before the shellcode starts processing.  

		\subsection{Other Mitigations}
			These are further mitigations that require further study. 
			Each of them has a weakness, but these weakness are beyond the scope of this document. 
			Where the weakness is well known, its name will be given alongside that of the mitigation. 

			Stack Hardening is the walling off of the stack from executable memory. 
			This means that any inserted shellcode stored within stack based memory will not be executable as the OS will know that it was never supposed to be run. 
			This is implemented in Linux through the Grsecurity and PaX patch sets, which when set up properly will completely block stack execution. 
			However, this can be overcome using the ``return to libc'' method.

			\index{ASLR}
			Randomized stack space is another mitigation that makes exploits harder. 
			This mitigation disrupts the convenient stack layout that we have used to our advantage within this chapter, randomizing it such that one cannot know where a variable will occur. 
			Since Linux version 2.6.12 this has been enabled by default, making the execution of shellcode which has been written onto the stack a matter of luck. 
			This can be overcome, but requires that you brute force the return address before being able to write shellcode which will work with it. 


	\section{Challenges}
		The shellcode found in \ref{code:ShellcodeReversePort} is the solution to the reverse TCP connection problem given in Attacking Remote Targets. 
		\begin{code}
			\lstinputlisting[language={[x86masm]Assembler}]{./ShellcodeReversePort.asm}
			\caption{Reverse socket connection shellcode challenge}
			\label{code:ShellcodeReversePort}
		\end{code}
		\newpage
		The overflow challenge found in code example \ref{code:OverflowChallenge} is another simple stack based overflow vulnerability. 
		Try to set the password to 0xDEADBEEF to login.
		This code should also be vulnerable to the introduction of shellcode to the return address of the stack frame. 
		\begin{code}
			\lstinputlisting[language={[ANSI]C}]{./OverflowChallenge.c}
			\caption{Overflow Challenge}
			\label{code:OverflowChallenge}
		\end{code}
